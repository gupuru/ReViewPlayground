={review-introduction} Re:VIEWの書き方

//lead{
本章ではRe:VIEWの記法を紹介します。
執筆にあたって適切なマークアップを選択できるよう、利用頻度の高いRe:VIEW記法について扱います。
//}

=={review_markup} 記法の紹介

Re:VIEW記法は、文章を書き、見出しやコードなどをマークアップするための記法です。
たとえば技術書では、文章や単語を強調したいときに@<b>{太字}にしたり、クラスやメソッドの名前を記述する場合、@<tt>{等幅フォント}にしたりすることで、視覚的に差別化することは一般的に行われています。
#@# REVIEW vvakame i とか tt は見た目の情報なので code とかを使ったほうがいいような…。

また、文章中でコード例や図版を挿入した時、文中からそれらを参照するために「リスト 2.1」などのように番号を振る必要がありますが、
Re:VIEWにはリストや図版の採番を自動的にするための仕組みがあります（@<list>{list_sample}）。
#@# REVIEW vvakame このあたりの解説、もうちょっと後ろに送ったほうがいいと思う…

//list[list_sample][通し番号の割り当て＋キャプションを表示]{
また、画像やプログラムリストを掲載する場合、視覚的に区別しやすくし、本文に対し適切な余白をとり、適切な場所に配置することも大切です。
//}

Re:VIEW記法でマークアップすることで文章の構造や見た目を記述することができます。
マークアップの巧拙が表現力の差となります。そして、より良い表現は、読者にとってより良い情報になります。

=== インライン命令とブロック命令

Re:VIEW記法は、「インライン命令」と「ブロック命令」の２つに分類できます。
#@# REVIEW vvakame インライン記法とブロック記法のほうが好きだな… どこからの表現だろう

==== インライン命令

インライン命令は@<tt>{＠<命令>{...}}のように、@<kw>{＠,アットマーク}に続けて括弧<>内に命令名を指定します。
続く括弧{}の中が、インライン命令の効果が及ぶ範囲になります。
#@# REVIEW vvakame tt より code が好きだなー

インライン命令は、文章の装飾やリストや図の参照など表示や内容に影響します。
文中に直接記入することができますが、改行をまたぐことはできません。

==== ブロック命令

#@# REVIEW vvakame ブロック記法についてはインライン記法より先に書くべきだと思う。インライン記法がなくてもemlistなどで技術書は書けるが、逆は真ではないからだ。

ブロック命令は@<list>{block_directive}のように、スラッシュ２つ（@<tt>{//}）に続けて命令名を指定します。
続く括弧{から、次の@<tt>{//}}までが、ブロック命令の効果が及ぶ範囲になります。

//list[block_directive][ブロック命令]{
 //命令{
 ...
 //}
//}

ブロック命令には複数のオプションを指定できる場合があります。
オプションは、命令に続けて括弧[]の中に記述します（@<list>{block_directive_with_option}）。

指定可能なオプションの数や省略の可否は、命令によって違います。

//list[block_directive_with_option][ブロック命令]{
 //命令[オプション1][オプション2][オプション3]{
 ...
 //}
//}

ブロック命令はリストや図など本文とは独立した内容を掲載する際に使います。

ブロック命令を文の途中から開始することはできません。ブロック命令の開始と終了は、必ず行頭に記述します。
行頭に半角スペースなどが入った場合、Re:VIEWは、その行をブロック命令として扱いません。

=== 見出し

#@# REVIEW vvakame 見出し は節の最初に持ってくるべきだと思う。.reの最初に出てくるのが見出しだからだ。

見出しは、=から始めて、キャプションを続けます。

@<code>{=}は、必ず行頭から開始します。
また、=の後ろには、必ず半角スペースを入れます。

@<code>{=}の数によって見出しの深さが変わります。
数に応じてそれぞれ章、節、項、段、小段の5段階に対応します（@<list>{captions}）。

//list[captions][キャプションと対応]{
= 章のキャプション

== 節のキャプション

=== 項のキャプション

==== 段のキャプション

===== 小段のキャプション
//}

Re:VIEWは６段階以上の見出しには対応していませんが、一般的な文書では「項」レベルまであれば十分でしょう。
章、節、項それぞれの見出しで含まれる内容のバランスを保つことで、読みやすい構造になります。

==== 参照

#@# REVIEW vvakame うーん、ここまでで概略を示し、ここから節レベルで詳細解説という区切りにして仕切りなおしたほうがいいように思うなぁ…。説明の順番を全体的に再考したい…。
#@# REVIEW vvakame 参照って利用頻度高くないので、もうちょっと後ろに回していいと思う。利用頻度高いものほど章頭に近いほうが嬉しいように思う。

他の見出しを参照し、文章中で利用することができます。
これを使わず、見出しのキャプションや番号を記述した場合、見出しの追加や削除、順番の変更が発生するたび関連箇所・ファイルを漏れなく探し出し、全てに修正を加えなくてはなりません。
一方、見出しの参照を使うと、章や節の順番の入れ替え、タイトルの変更などが自動的に反映されます。

見出しの参照は、大きく「章の参照」と「節の参照」の２つに分類できます。

===== 章の参照

章を参照する構文です。

@<list>{refer_chap}は、３つとも@<chapref>{writing-book}を参照しています。

//list[refer_chap][章の参照]{
＠<title>{writing-book}

＠<chap>{writing-book}

＠<chapref>{writing-book}
//}

@<tt>{title}は、その章のキャプションになります（@<title>{writing-book}）。

@<tt>{chap}は、その章の見出し番号になります（@<chap>{writing-book}）。

@<tt>{chapref}は、その章の見出し番号とキャプションになります（@<chapref>{writing-book}）。

これらの構文の参照先には、Re:VIEWの章の識別子を指定します。

章の識別子は、Re:VIEWの章のファイル名から拡張子@<tt>{.re}を取り除いた名前です。
たとえば、@<tt>{writing-book.re}の章を参照する場合、@<tt>{writing-book}が識別子になります。

===== 節の参照

章より一段深い階層にある「節」を参照する構文です（@<list>{refer_section}）。

//list[refer_section][見出しの参照]{
＠<hd>{見出し}

＠<hd>{writing-book|Re:VIEWの特色}
//}

同じ章の節を参照する場合、参照先には、節のキャプションだけを記載します。

異なる章の見出しを参照する場合、章の識別子を指定した上で、縦棒@<tt>{|}で区切って節のキャプションを記述します。

章の識別子は、Re:VIEWの章のファイル名から拡張子@<tt>{.re}を取り除いた名前です。
たとえば、@<tt>{writing-book.re}の章を参照する場合、@<tt>{writing-book}が識別子になります。

===== 見出しラベル

節の参照では、見出しのキャプションをそのまま記述するので、キャプションを変更したときに参照を更新する必要があります。

Re:VIEWでは、見出しキャプションとは別に、参照用のラベルを指定できます。

//list[section_label][見出しの参照用ラベル]{
 =={review_markup} Re:VIEW記法
//}

@<list>{section_label}の括弧{}の中が節の識別子になり、@<list>{refer_section_label}のように参照します。

//list[refer_section_label][見出しの参照]{
＠<hd>{review_markup}
//}

通常の節の参照同様、違う章の節を参照することができる優れものです。

=== リード文

ひとまとまりの文章の内容を、簡単に説明する短い文章を「リード文」と言います。
#@# REVIEW vvakame この本の全ての章にリード文入れたほうがいいっすかね？

//list[sammple_lead][リード文]{
 //lead{
 本章ではRe:VIEWで執筆をする上でもっとも重要となるRe:VIEW記法について解説します。
 //}
//}

@<list>{sammple_lead}のマークアップは、次のように出力されます。

//lead{
本章ではRe:VIEWで執筆をする上でもっとも重要となるRe:VIEW記法について解説します。
//}

このように、リード文としてマークアップした内容は、本文に比べて左側の余白が大きくなります。

Re:VIEWでは、リード文のマークアップは文章のどこにでも置くことができます。
しかし、基本的には見出し、特に章見出しの直下に置くことを想定しています。

=== 段落と改行

文章と文章の間に空行を挟むと、それぞれが個別の段落として処理されます。


２つ以上空行を入れても段落分けには影響しません。


また、Re:VIEWでは、
空行を挟まない改行は無視され、出力には影響しません。      １つ以上の半角スペースも、出力には影響しません。

＠<br>{}を使うと、強制的に@<br>{}
改行@<br>{}
できます。

//emlist[sections][段落を含む文章]{
Re:VIEW記法の段落は、空行を挟んで文章を続けます。


２つ以上空行を入れても段落分けには影響しません。

また、Re:VIEWでは、
空行を挟まない改行は無視され、出力には影響しません。      １つ以上の半角スペースも、出力には影響しません。

＠<br>{}を使うと、強制的に＠<br>{}
改行＠<br>{}
できます。
//}

=== コメント

行が@<tt>{#@#}から始まる場合、その行についてはコメントとして扱われ、最終出力には影響しません。

#@#この行はコメントです。
Re:VIEWは、複数行コメントには対応していません。
複数行をコメントとして扱うには、すべての行に@<tt>{#@#}を含める必要があります。

//emlist[comments][コメント]{
コメントの内容は、出力に影響しません。

#＠#この行はコメントです。
Re:VIEWは、複数行コメントには対応していません。
複数行をコメントとして扱うには、すべての行に#@#を記述する必要があります。
//}

=== 箇条書き

項目を列挙する際に、箇条書きを利用できます。
Re:VIEWは、「番号なし箇条書き」と「番号つき箇条書き」に対応しています。

==== 番号なし箇条書き

*に続けて項目を記述すると箇条書きになります。
番号なし箇条書きはツリー構造も表現できるようになっていて、*の数がそのまま深さになります。

*の前後には、半角スペースが必要です。半角スペースがない場合は、Re:VIEWはその行を本文として取り扱います。

//list[num_sample][番号無し箇条書き]{
 * 箇条書き
 ** 2層目
 *** 3層目
 ** 2層目
 * 箇条書き
//}

@<list>{num_sample}のマークアップは、次のように出力されます。

 * 箇条書き
 ** 2層目
 *** 3層目
 ** 2層目
 * 箇条書き

==== 番号あり箇条書き

@<code>{1. }に続いて項目を続けると箇条書きになります。

先頭とピリオドの後に半角スペースが必要です。番号あり箇条書きは、入れ子に対応していません。

//list[num_sample2][番号付き箇条書き]{
 1. 番号つき箇条書き
 2. 番号つき箇条書き
 3. 番号つき箇条書き
//}

@<list>{num_sample2}のマークアップは、次のように出力されます。

 1. 番号つき箇条書き
 2. 番号つき箇条書き
 3. 番号つき箇条書き

また番号部分の連番を誤った場合でも自動的に連番に置き換わります。
//list[num_sample3][番号付き箇条書き]{
 1. 番号つき箇条書き
 2. 番号つき箇条書き
 2. 番号つき箇条書き
//}

@<list>{num_sample3}のマークアップは、次のように出力されます。

 1. 番号つき箇条書き
 2. 番号つき箇条書き
 3. 番号つき箇条書き

このように、番号部分は自動的に連番に置き換わります。
しかし、行の追加や削除の際は、可能な限り番号を書き換えることをお勧めします。
本文中で3番は〜などと言及した時に文書上の項番が中途半端に振られていると、ミスの原因となるからです。
これを避けることで、組版や校正時のミスを予防できます。

=== リスト

プログラムコードなど、本文とは分けて掲載する内容を「リスト」と言います。
リストの中の改行やスペースはそのまま出力されます。

@<hd>{段落と改行}で述べたとおり、Re:VIEWでは本文中の複数の半角スペースや改行は、本文には影響しません。
しかし、プログラムなどを掲載したい場合、改行やインデントなどはそのまま出力する必要があります。
このような場合にリストは有用です。

Re:VIEWのリストには、連番付きと連番無しの２種類、行番号の有無を含めると計４種類があります。

//table[list_table][リストの区分]{
.	行番号なし	行番号あり
-------------------------
連番付き	list	listnum
連番なし	emlist	emlistnum
//}

連番つきリストにするとRe:VIEWは、リストごとに一意な番号を割り振ります。

//list[list_sample_with_seq][連番付きリスト]{
@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
}
//}

番号が割り当てられたリストは、@<list>{refer_list_sample_with_seq}のように本文から参照できます。

//list[refer_list_sample_with_seq][リストの参照]{
番号が割り当てられたリストは、＠<list>{list_sample_with_seq}のように本文から参照できます。
//}

一方、連番なしリストは、リストに番号を割り当てません。

//emlist[連番無しリスト]{
@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
}
//}

番号が割り当てられていない場合、本文からは参照できません。

一般的に、ソースコードリストのように本文から参照する場合には、連番付きリスト（list）を推奨します。
参照関係が明らかな場合のみ、連番なしリスト（emlist）を利用するといいでしょう。

==== 連番つきリスト

連番付きのリストです。

キャプションには、ソースコードファイル名や処理内容など、リストの示す内容を簡潔に記述します。
連番付きリストのキャプションは省略できません。

//list[list_sample_with_seq2][連番付きリスト]{
 //list[identifier][連番付きリストのキャプション]{
  ...ソースコード等...
 //}
//}

@<list>{list_sample_with_no_seq2}のマークアップは、次のように出力されます。

//list[identifier_dummy1][連番付きリストのキャプション]{
 ...ソースコード等...
//}

＠<list>{@<tt>{identifier}}で、@<kw>{identifier,識別子}が示すリストを参照できます。
参照は、出力時に「@<list>{list_sample_with_seq2}」のようにリスト番号に置き換わります。

==== 連番なしリスト

連番なしのリストです。

キャプションには、ソースコードファイル名や処理内容など、リストの示す内容を簡潔に記述します。
連番なしリストのキャプションは省略できます。

//list[list_sample_with_no_seq2][連番なしリスト]{
 //emlist[連番なしリストのキャプション（省略可能）]{
  ...ソースコード等...
 //}
//}

@<list>{list_sample_with_no_seq2}のマークアップは、次のように出力されます。

//emlist[連番なしリストのキャプション（省略可能）]{
 ...ソースコード等...
//}

連番無しリストは、本文中からの参照はできません。

==== 連番つきリスト（行番号有り）

連番付きのリストで、かつ、自動的に行番号が表示されます。

キャプションには、ソースコードファイル名や処理内容など、リストの示す内容を簡潔に記述します。
連番付きリストのキャプションは省略できません。

//list[listnum_sample_with_seq2][行番号有り連番付きリスト]{
 //listnum[identifier][行番号有り連番付きリストのキャプション]{
  ...
  ソースコード等
  ...
 //}
//}

@<list>{listnum_sample_with_seq2}のマークアップは、次のように出力されます。

//listnum[identifier_dummy2][行番号有り連番付きリストのキャプション]{
 ...
 ソースコード等
 ...
//}

＠<list>{@<tt>{identifier}}で、@<kw>{identifier,識別子}が示すリストを参照できます。
参照は、出力時に「@<list>{listnum_sample_with_seq2}」のようにリスト番号に置き換わります。

==== 連番なしリスト（行番号有り）

連番なしのリストで、かつ、自動的に行番号が表示されます。

キャプションには、ソースコードファイル名や処理内容など、リストの示す内容を簡潔に記述します。
連番なしリストのキャプションは省略できます。

//list[emlistnum_sample_with_no_seq2][行番号有り連番なしリスト]{
 //emlistnum[行番号有り連番なしリストのキャプション（省略可能）]{
 ...
 ソースコード等
 ...
 //}
//}

@<list>{emlistnum_sample_with_no_seq2}のマークアップは、次のように出力されます。

//emlistnum[行番号有り連番なしリストのキャプション（省略可能）]{
...
ソースコード等
...
//}

連番無しリストは、本文中からの参照はできません。

行番号をつける場合は、通常、本文からの参照・説明を意図していることが多く、利用頻度がきわめて低い構文です。
#@# REVIEW vvakame 後述 が相当あとの予感がするので何かリンクなりが欲しい…
#@# REVEIW KG 後述の不具合はもう直ってるで。前の本から内容を持ってくるのはいいけど、ちゃんと検証しような

=== コマンドライン

コマンドラインの入出力などを示す構文です。

//list[cmd_sample][引用]{
 //cmd{
 $ git add .gitignore
 $ git commit -m "first commit"
 //}
//}

@<list>{cmd_sample}のマークアップは、次のように出力されます。

//cmd{
$ git add .gitignore
$ git commit -m "first commit"
//}

Re:VIEWは、コマンドラインの中の改行やスペースをそのまま出力します。

また、コマンドラインは、本文中からの参照はできません。

=== 引用

ウェブサイトや書籍などから引用した文章を示す構文です。

//list[quote_sample][コマンドライン]{
 //quote{
 文章を記述するための軽量マークアップ言語はRe:VIEWの他にもいくつもあります。
 たとえば、Wikipediaなどで使われるWiki記法も軽量マークアップ言語です。
 IT技術者業界では、他にもMarkdown,reStructuredText,Textileといった例があります。
 //}
//}

@<list>{quote_sample}のマークアップは次のように出力されます。

//quote{
文章を記述するための軽量マークアップ言語はRe:VIEWの他にもいくつもあります。
たとえば、Wikipediaなどで使われるWiki記法も軽量マークアップ言語です。
IT技術者業界では、他にもMarkdown,reStructuredText,Textileといった例があります。
//}

Re:VIEWは引用の中の改行やスペースをそのまま出力します。
また、引用は本文中からの参照はできません。

=== リンク

URLをリンクとしてマークアップする構文です。

リンクには、出力したときにURLを表示する場合と、しない場合の２つの方法があります。

@<list>{link_sample_with_url}は、URLを表示する場合です。

//list[link_sample_with_url][URLリンク]{
＠<href>{http://techbooster.org}
//}

@<list>{link_sample_with_url}を出力した結果は、"@<href>{http://techbooster.org}"のようにURLがそのまま表示されます。

また@<list>{link_sample}は、URLを表示しない場合です。

URLに加えて、コンマで区切ってリンクを設定する文字列を続けます。

//list[link_sample][リンク（URL無し）]{
＠<href>{http://techbooster.org,TechBooster}
//}

@<list>{link_sample}を出力した結果は、"@<href>{http://techbooster.org,TechBooster}"のようにURLが表示されず、文字列にリンクが設定された状態になります。

当然のことながら、どちらの場合でも紙に印刷するとリンクは使えなくなりますが、URLを表示する方法では印刷後でもURLそのものは分かるので、
最終的に印刷する場合は、URLを表示する方法が適しています。

=== 脚注

本文に別の情報を付記する構文です。「注釈」とも呼ばれます。

@<list>{footnote_sample}は、脚注を記述した例です。

//list[footnote_sample][コマンドライン]{
 //footnote[identifier][脚注の内容は、ページで本文とは別の「脚注の領域」に表示されます]
//}

//footnote[about_footnote][脚注の内容は、ページで本文とは別の「脚注の領域」に表示されます]
#@# //footnote[not_reffered_footnote][参照されない脚注は表示されません]

脚注は、記述した場所に関係なく「脚注の領域」に表示されます。

脚注を有効にするには、本文で参照している必要があります。本文で参照されていない脚注は出力されません。

@<list>{footnote_refer_sample}では、記述した脚注を参照しています。

//list[footnote_refer_sample][脚注への参照]{
本文から参照すると、脚注番号が付記されます＠<fn>{identifier}。
//}

＠<fn>{@<tt>{identifier}}で、@<kw>{identifier,識別子}が示す脚注を参照できます。

本文から参照すると、脚注番号が付記されます@<fn>{about_footnote}。

=== 図

写真や挿絵などを「図」として、本文中に差し込むことができます。

差し込む写真や図面などは別ファイルで保存しておき、本文中に参照を記述します。

==== 画像ファイル

本文に差し込む画像ファイルは、Re:VIEWファイルがあるディレクトリに@<code>{images}ディレクトリを作成します。
それぞれの画像ファイルは、その画像を差し込む章の名前のディレクトリの下に配置します。

たとえば、@<tt>{markup.re}の章に表示する画像ファイル@<tt>{image_sample.png}の場合、@<tt>{images/markup/image_sample.png}となります。
このことから解るとおり、Re:VIEWでは、異なる章の画像ファイルを直接参照することはできません。
画像ファイルは、章ごとに配置する必要があります。

画像ファイルとして利用できるフォーマットはRe:VIEWで出力する形式に依存しますが、
PNG、JPEG、@<kw>{SVG,Scalable Vector Graphics}など、基本的なフォーマットには対応しています。

#@# REVIEW vvakame 画像の対応フォーマットとか○○がインストールしてあると☓☓も使える…とかはいらない？

==== 連番付きの図

キャプションには、ファイル名や処理内容など、内容を簡潔に記述します。
キャプションは省略できません。

//list[image_sample_with_seq][連番付きの図]{
 //image[image_sample][連番付きの図]{
 ...代替テキスト等...
 //}
//}

@<list>{image_sample_with_seq}のマークアップは、次のように出力されます。

//image[image_sample_dup1][連番付きの図]{
//}

＠<img>{@<tt>{identifier}}で、本文から@<kw>{identifier,識別子}が示す図を参照できます。

参照は出力時に「@<img>{image_sample_dup1}」のようにリスト番号に置き換わります。

@<tt>{代替テキスト}は、出力時には無視されます。
基本的にはアスキーアートや文章で画像の説明をして、執筆時にどんな画像を意図しているのか確認するために使いますが、何も書かなくても問題ありません。

==== 連番なしの図

キャプションには、ファイル名や処理など内容を簡潔に記述します。
キャプションは省略できません。

//list[image_sample_with_no_seq][連番なしの図]{
 //indepimage[image_sample][連番なしの図]
//}

@<list>{image_sample_with_no_seq}のマークアップは、次のように出力されます。

//indepimage[image_sample][連番なしの図]

連番なしの図は、本文中からの参照はできません。また、@<tt>{代替テキスト}は指定できません。

==== 図のサイズを指定する

スケールオプションで図の表示倍率を指定することができます。

スケールオプションは、@<code>{image}、@<code>{indepimage}に括弧[]を追加して、@<tt>{scale=}に続いて表示倍率を指定します。

表示倍率は、@<tt>{1.0}を等倍、@<tt>{0.0}を下限として指定できます。

//list[scaled_image_sample_with_seq][連番付きの図]{
 //image[image_sample][表示倍率50%]@<b>{[scale=0.5]}{
 ...代替テキスト等...
 //}
//}

//image[image_sample_dup2][表示倍率50%][scale=0.5]{
...代替テキスト等...
//}

//list[scaled_image_sample_with_no_seq][連番なしの図]{
 //indepimage[image_sample][表示倍率25%]@<b>{[scale=0.25]}
//}

//indepimage[image_sample][表示倍率25%][scale=0.25]

スケールオプションを省略した場合、Re:VIEWは自動で適切なサイズを選択します。
スケールを指定した結果、図が紙面からはみ出る場合もあるので注意してください。

=== 表

罫線で区切られた表をマークアップする構文です。

Re:VIEWでは、行は改行、セルとセルの間にはタブで区切ります。

空白のセルは、ピリオド（@<tt>{.}）を入力します。

セルにピリオドを表示したい、またはセルの内容をピリオドから始めたい場合、ピリオドを２つ続けて（@<tt>{..}）入力します。

また、@<tt>{-------------}で区切ることで、ヘッダの行を明確に指定できます。

//list[table_sample][表]{
 //table[identifier][表のキャプション]{
 .	A	B	C	D	E
 ------------------
 1	2012	500	800	1.0	..15
 2	2013	600	.	1.1	..13
 3	2014	900	1200	1.4	..18
 //}
//}

@<list>{table_sample}のマークアップは、@<table>{table_sample}のように出力されます。

//table[table_sample][表のキャプション]{
.	A	B	C	D	E
------------------
1	2012	500	800	1.0	..15
2	2013	600	.	1.1	..13
3	2014	900	1200	1.4	..18
//}

＠<table>{@<tt>{identifier}}で、@<kw>{identifier,識別子}が示す表を参照できます。
参照は、出力時に「@<table>{table_sample}」のように表番号に置き換わります。

=== 文字の装飾

Re:VIEW記法では文字を装飾することができます。

文字の装飾は適用したい範囲を@<tt>{＠<修飾子>{...}}で指定するだけです。

また文字の装飾は、本文だけでなくリストや脚注、表などの中でも有効です。
利用頻度の高い文字の装飾について@<table>{character_decorations}にまとめています。

//table[character_decorations][文字の装飾]{
修飾子	説明	例
------------------
＠<b>{文字列}	太字（ボールド）フォント	@<b>{abcdefg あいうえお}
＠<i>{文字列}	イタリックフォント	@<i>{abcdefg あいうえお}
＠<tt>{文字列}	等幅フォント	@<tt>{abcdefg あいうえお}
＠<ttb>{文字列}	太字（ボールド）＆等幅フォント	@<ttb>{abcdefg あいうえお}
＠<tti>{文字列}	イタリック＆等幅フォント	@<tti>{abcdefg あいうえお}
＠<em>{文字列}	強調	@<em>{abcdefg あいうえお}
＠<strong>{文字列}	強調	@<strong>{abcdefg あいうえお}
＠<ami>{文字列}	網掛け	@<ami>{abcdefg あいうえお}
＠<kw>{キーワード,解説}	キーワードと解説	@<kw>{GNU,GNU is Not Unix}
//}

== プリプロセッサ命令

Re:VIEWでは、最終的な見た目に影響する記法とは別に、外部の情報を.reファイルに反映する「プリプロセッサ命令」があります。
プリプロセッサ命令を使うことで、外部ファイルとしているサンプルコードを自動で.reファイル内に反映できます。

プリプロセッサ命令を処理するには@<code>{review-preproc}コマンドを使用します。
@<code>{review-preproc}コマンドは、PDFのビルド時に自動で実行するようにしておくと便利です。
@<hd>{tips|config_task_runner}を参照してください。

プリプロセッサ命令は、あくまで.reファイルの一部を書き換えるだけです。
最終的に.reファイルの内容がビルドされることに変わりはありません。

=== ファイルの内容を読み込む

@<code>{mapfile}命令は、外部ファイルの内容をすべて読み込みます。
外部ファイルを読み込む箇所に@<code>{#@mapfile(file_name)}と読み込み範囲の終了示す@<code>{#@end}を記述します。
@<code>{review-preproc}コマンドは@<code>{#@mapfile(file_name)}と@<code>{#@end}の間にファイル@<code>{file_name}を読み込みます。

たとえばサンプルコードfoo.rbを読み込む場合、@<list>{sample_mapfile_before}のように記述します。

//list[sample_mapfile_before][コンパイル前のmapfile記述]{
 //list[sample_code][サンプルコード]{
 #@mapfile(foo.rb)
 #@end
 //}
//}

@<list>{sample_mapfile_before}は@<code>{review-preproc}コマンドの処理後に@<list>{sample_mapfile_after}のようになります。
Re:VIEWは@<code>{#@〜}の行をPDFやHTMLファイルなどの最終的な成果物には出力せず、foo.rbの内容だけを出力します。

//list[sample_mapfile_after][コンパイル後のmapfile記述]{
 //list[sample_code][サンプルコード]{
 #@mapfile(foo.rb)
 puts "foo"
 #@end
 //}
//}

==== tabwidthオプション

@<code>{review-preproc}コマンドは@<code>{tabwidth}オプションを使うと、
プリプロセッサ命令で読み込むファイルのタブ文字を任意の数のスペースに置換します。

紙面の都合上、TechBoosterではサンプルコードのインデントは２スペースとしています。
しかし、サンプルコードを最初から２スペースのインデントで書くというのはあまりやりたくありません。
タブ文字でインデントしておけば原稿に反映する際に自動でインデントの文字幅を置換できます。
サンプルコードを編集するエディタ上ではタブ文字を好みの幅で表示しましょう。

@<code>{tabwidth}オプションは@<code>{--tabwidth=WIDTH}という形式で指定します。
たとえば、sample.reに対して@<code>{review-preproc}コマンドを実行しタブ文字を２スペースに置換するには、次のようにします。

//cmd{
$ review-preproc -r --tabwidth=2 sample.re
//}

このオプションが効くのは、あくまでプリプロセッサ命令で読み込むファイルの内容のみです。
@<code>{mapfile}などを使わず@<code>{list}ブロック内に直接コードを書いている場合は、
@<code>{review-compile}コマンドの@<code>{tabwidth}オプションを使えば、出力結果のインデントを調整できます。

=== ファイルの内容の一部を読み込む

@<code>{maprange}命令は、外部ファイルの一部を読み込みます。
ただし、外部のファイル側に読み込み範囲を示すプリプロセッサ命令を記述しておく必要があります。

@<code>{#@range_begin(range_name)}と@<code>{#@range_end(range_name)}で範囲を括ります。
@<list>{sample_maprange_source}は、@<code>{#@range_begin(range_name)}と@<code>{#@range_end(range_name)}を記述した例です。

//list[sample_maprange_source][maprangeで読み込むsrc.txt]{
 ここは読み込みません。
 #@range_begin(sample)
 ここを読み込みます。
 #@range_end(sample)
 ここは読み込みません。
//}

@<list>{sample_maprange_source}で指定した範囲を読み込むには、.reファイルに@<list>{sample_maprange_before}のように記述します。
また、@<code>{#@maprange(...)}は@<code>{#@map(...)}と記述しても動作します。

//list[sample_maprange_before][コンパイル前のmaprange記述]{
 //list[sample_code][サンプルコード]{
 #@maprange(src.txt, sample)
 #@end
 //}
//}

@<list>{sample_maprange_before}は@<code>{review-preproc}コマンドの処理後に@<list>{sample_maprange_after}のようになります。

//list[sample_maprange_after][コンパイル後のmaprage]{
 //list[sample_code][サンプルコード]{
 #@maprange(src.txt, sample)
 ここを読み込みます。
 #@end
 //}
//}

=== 外部コマンドの結果を読み込む

@<code>{mapoutput}命令は、外部コマンドの結果を読み込みます。
この命令はRe:VIEWの記法の枠内に囚われず、任意の処理の結果を.reファイルに埋め込めます。
しかし、あくまでコンパイルするマシンにインストールしているコマンドを使用するため、複数人で執筆する場合は注意が必要です。

たとえば、筆者の環境のjavaのバージョンを自動で埋め込む場合は@<list>{sample_mapoutput_before}のように記述します。

//list[sample_mapoutput_before][java -version]{
 #@mapoutput(java -version 2>&1)
 #@end
//}

@<list>{sample_mapoutput_before}は、コンパイル後に@<list>{sample_mapoutput_after}のようになります。

//list[sample_mapoutput_after][java -version]{
 #@mapoutput(java -version 2>&1)
 java version "1.8.0_05"
 Java(TM) SE Runtime Environment (build 1.8.0_05-b13)
 Java HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)
 #@end
//}

#@# REVIEW KG ここからは前のでは別の章にあったと思うんだけど、なんでまとめたん？　ここからは「書き方」じゃないよね？
#@# REVIEW mstssk 分離しました。
